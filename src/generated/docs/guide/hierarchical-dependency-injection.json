{
  "id": "guide/hierarchical-dependency-injection",
  "title": "Hierarchical Dependency Injectors",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/hierarchical-dependency-injection.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<h1 id=\"hierarchical-dependency-injectors\">Hierarchical Dependency Injectors<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#hierarchical-dependency-injectors\"><i class=\"material-icons\">link</i></a></h1>\n<p>The Angular dependency injection system is <em>hierarchical</em>.\nThere is a tree of injectors that parallels an app's component tree.\nYou can reconfigure the injectors at any level of that component tree.</p>\n<p>This guide explores this system and how to use it to your advantage.\nIt uses examples based on this <live-example></live-example>.</p>\n<a id=\"ngmodule-vs-comp\"></a>\n<a id=\"where-to-register\"></a>\n<h2 id=\"where-to-configure-providers\">Where to configure providers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#where-to-configure-providers\"><i class=\"material-icons\">link</i></a></h2>\n<p>You can configure providers for different injectors in the injector hierarchy.\nAn internal platform-level injector is shared by all running apps.\nThe <code>AppModule</code> injector is the root of an app-wide injector hierarchy, and within\nan NgModule, directive-level injectors follow the structure of the component hierarchy.</p>\n<p>The choices you make about where to configure providers lead to differences in the final bundle size, service <em>scope</em>, and service <em>lifetime</em>.</p>\n<p>When you specify providers in the <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> decorator of the service itself (typically at the app root level), optimization tools such as those used by the CLI's production builds can perform <em>tree shaking</em>, which removes services that aren't used by your app. Tree shaking results in smaller bundle sizes. </p>\n<ul>\n<li>Learn more about <a href=\"guide/dependency-injection-providers#tree-shakable-providers\">tree-shakable providers</a>.</li>\n</ul>\n<p>You're likely to inject <code>UserService</code> in many places throughout the app and will want to inject the same service instance every time. Providing <code>UserService</code> through the <code>root</code> injector is a good choice, and is the default that the <a href=\"cli\">Angular CLI</a> uses when you generate a service for your app.</p>\n<div class=\"alert is-helpful\">\n<header>Platform injector</header>\n<p>When you use <code><a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>:'root'</code>, you are configuring the root injector for the <em>app</em>, which is the injector for <code>AppModule</code>.\nThe actual root of the entire injector hierarchy is a <em>platform injector</em> that is the parent of app-root injectors.\nThis allows multiple apps to share a platform configuration. For example, a browser has only one URL bar, no matter how many apps you have running.</p>\n<p>The platform injector is used internally during bootstrap, to configure platform-specific dependencies. You can configure additional platform-specific providers at the platform level by supplying <code>extraProviders</code> using the <code><a href=\"api/platform-browser/platformBrowser\" class=\"code-anchor\">platformBrowser</a>()</code> function. </p>\n<p>Learn more about dependency resolution through the injector hierarchy:\n<a href=\"https://blog.angularindepth.com/angular-dependency-injection-and-tree-shakeable-tokens-4588a8f70d5d\">What you always wanted to know about Angular Dependency Injection tree</a></p>\n</div>\n<p><em>NgModule-level</em> providers can be specified with <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> <code>providers</code> metadata option, or in the <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> <code><a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a></code> option (with some module other than the root <code>AppModule</code>).</p>\n<p>Use the <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> <code>providers</code> option if a module is <a href=\"guide/lazy-loading-ngmodules\">lazy loaded</a>. The module's own injector is configured with the provider when that module is loaded, and Angular can inject the corresponding services in any class it creates in that module. If you use the <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> option <code><a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: MyLazyloadModule</code>, the provider could be shaken out at compile time, if it is not used anywhere else in the app. </p>\n<ul>\n<li>Learn more about <a href=\"guide/dependency-injection-providers#tree-shakable-providers\">tree-shakable providers</a>.</li>\n</ul>\n<p>For both root-level and module-level injectors, a service instance lives for the life of the app or module, and Angular injects this one service instance in every class that needs it.</p>\n<p><em>Component-level</em> providers configure each component instance's own injector.\nAngular can only inject the corresponding services in that component instance or one of its descendant component instances.\nAngular can't inject the same service instance anywhere else. </p>\n<p>A component-provided service may have a limited lifetime.\nEach new instance of the component gets its own instance of the service.\nWhen the component instance is destroyed, so is that service instance.</p>\n<p>In our sample app, <code>HeroComponent</code> is created when the application starts\nand is never destroyed,\nso the <code>HeroService</code> instance created for <code>HeroComponent</code> lives for the life of the app.\nIf you want to restrict <code>HeroService</code> access to <code>HeroComponent</code> and its nested\n<code>HeroListComponent</code>, provide <code>HeroService</code> at the component level, in <code>HeroComponent</code> metadata.</p>\n<ul>\n<li>See more <a href=\"guide/hierarchical-dependency-injection#component-injectors\">examples of component-level injection</a> below.</li>\n</ul>\n<a id=\"register-providers-injectable\"></a>\n<h3 id=\"injectable-level-configuration\">@Injectable-level configuration<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#injectable-level-configuration\"><i class=\"material-icons\">link</i></a></h3>\n<p>The <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> decorator identifies every service class. The <code><a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a></code> metadata option for a service class configures a specific injector (typically <code>root</code>)\nto use the decorated class as a provider of the service.\nWhen an injectable class provides its own service to the <code>root</code> injector, the service is available anywhere the class is imported. </p>\n<p>The following example configures a provider for <code>HeroService</code> using the <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> decorator on the class.</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.0.ts\" header=\"src/app/heroes/heroes.service.ts\" linenums=\"false\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root',\n})\nexport class HeroService {\n  constructor() { }\n}\n\n\n</code-example>\n<p>This configuration tells Angular that the app's root injector is responsible for creating an\ninstance of <code>HeroService</code> by invoking its constructor,\nand for making that instance available across the application. </p>\n<p>Providing a service with the app's root injector is a typical case,\nand the CLI sets up this kind of a provider automatically for you\nwhen generating a new service.\nHowever, you might not always want to provide your service at the root level.\nYou might, for instance, want users to explicitly opt-in to using the service.</p>\n<p>Instead of specifying the <code>root</code> injector, you can set <code><a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a></code> to a specific NgModule. </p>\n<p>For example, in the following excerpt, the <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> decorator configures a provider\nthat is available in any injector that includes the <code>HeroModule</code>.</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.4.ts\" header=\"src/app/heroes/hero.service.ts\" linenums=\"false\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { HeroModule } from './hero.module';\nimport { HEROES } from './mock-heroes';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  // we declare that this service should be created\n  // by any injector that includes HeroModule.\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: HeroModule,\n})\nexport class HeroService {\n  getHeroes() { return HEROES; }\n}\n\n\n</code-example>\n<p>This is generally no different from configuring the injector of the NgModule itself,\nexcept that the service is tree-shakable if the NgModule doesn't use it.\nIt can be useful for a library that offers a particular service that some\ncomponents <em>might</em> want to inject optionally,\nand leave it up to the app whether to provide the service.</p>\n<ul>\n<li>Learn more about <a href=\"guide/dependency-injection-providers#tree-shakable-providers\">tree-shakable providers</a>.</li>\n</ul>\n<h3 id=\"ngmodule-level-injectors\">@NgModule-level injectors<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#ngmodule-level-injectors\"><i class=\"material-icons\">link</i></a></h3>\n<p>You can configure a provider at the module level using the <code><a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a></code> metadata option for a non-root NgModule, in order to limit the scope of the provider to that module.\nThis is the equivalent of specifying the non-root module in the <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> metadata, except that the service provided this way is not tree-shakable.</p>\n<p>You generally don't need to specify <code>AppModule</code> with <code><a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a></code>, because the app's <code>root</code> injector is the <code>AppModule</code> injector.\nHowever, if you configure a app-wide provider in the<code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> metadata for <code>AppModule</code>,\nit overrides one configured for <code>root</code> in the <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> metadata.\nYou can do this to configure a non-default provider of a service that is shared with multiple apps. </p>\n<p>Here is an example of the case where the component router configuration includes\na non-default <a href=\"guide/router#location-strategy\">location strategy</a> by listing its provider\nin the <code>providers</code> list of the <code>AppModule</code>.</p>\n<code-example path=\"dependency-injection-in-action/src/app/app.module.ts\" region=\"providers\" header=\"src/app/app.module.ts (providers)\" linenums=\"false\">\nproviders: [\n  { provide: <a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a>, useClass: <a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a> }\n]\n\n</code-example>\n<a id=\"register-providers-component\"></a>\n<h3 id=\"component-level-injectors\">@Component-level injectors<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#component-level-injectors\"><i class=\"material-icons\">link</i></a></h3>\n<p>Individual components within an NgModule have their own injectors.\nYou can limit the scope of a provider to a component and its children\nby configuring the provider at the component level using the <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> metadata.</p>\n<p>The following example is a revised <code>HeroesComponent</code> that specifies <code>HeroService</code> in its <code>providers</code> array. <code>HeroService</code> can provide heroes to instances of this component, or to any child component instances. </p>\n<code-example path=\"dependency-injection/src/app/heroes/heroes.component.1.ts\" header=\"src/app/heroes/heroes.component.ts\" linenums=\"false\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\nimport { HeroService } from './hero.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-heroes',\n  providers: [ HeroService ],\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n    &#x3C;h2>Heroes&#x3C;/h2>\n    &#x3C;app-hero-list>&#x3C;/app-hero-list>\n  `\n})\nexport class HeroesComponent { }\n\n\n</code-example>\n<h3 id=\"element-injectors\">Element injectors<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#element-injectors\"><i class=\"material-icons\">link</i></a></h3>\n<p>An injector does not actually belong to a component, but rather to the component instance's anchor element in the DOM. A different component instance on a different DOM element uses a different injector.</p>\n<p>Components are a special type of directive, and the <code>providers</code> property of\n<code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> is inherited from <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code>.\nDirectives can also have dependencies, and you can configure providers\nin their <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> metadata.\nWhen you configure a provider for a component or directive using the <code>providers</code> property, that provider belongs to the injector for the anchor DOM element. Components and directives on the same element share an injector.</p>\n<!--- TBD with examples\n* For an example of how this works, see [Element-level providers](guide/dependency-injection-in-action#directive-level-providers).\n--->\n<ul>\n<li>Learn more about <a href=\"https://blog.angularindepth.com/a-curios-case-of-the-host-decorator-and-element-injectors-in-angular-582562abcf0a\">Element Injectors in Angular</a>.</li>\n</ul>\n<h2 id=\"injector-bubbling\">Injector bubbling<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#injector-bubbling\"><i class=\"material-icons\">link</i></a></h2>\n<p>Consider this guide's variation on the Tour of Heroes application.\nAt the top is the <code>AppComponent</code> which has some subcomponents, such as the <code>HeroesListComponent</code>.\nThe <code>HeroesListComponent</code> holds and manages multiple instances of the <code>HeroTaxReturnComponent</code>.\nThe following diagram represents the state of this three-level component tree when there are three instances of <code>HeroTaxReturnComponent</code> open simultaneously.</p>\n<figure>\n  <img src=\"generated/images/guide/dependency-injection/component-hierarchy.png\" alt=\"injector tree\" width=\"600\" height=\"224\">\n</figure>\n<p>When a component requests a dependency, Angular tries to satisfy that dependency with a provider registered in that component's own injector.\nIf the component's injector lacks the provider, it passes the request up to its parent component's injector.\nIf that injector can't satisfy the request, it passes the request along to the next parent injector up the tree.\nThe requests keep bubbling up until Angular finds an injector that can handle the request or runs out of ancestor injectors.\nIf it runs out of ancestors, Angular throws an error. </p>\n<p>If you have registered a provider for the same DI token at different levels, the first one Angular encounters is the one it uses to provide the dependency. If, for example, a provider is registered locally in the component that needs a service, Angular doesn't look for another provider of the same service.  </p>\n<div class=\"alert is-helpful\">\n<p>You can cap the bubbling by adding the <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> parameter decorator on the dependant-service parameter\nin a component's constructor.\nThe hunt for providers stops at the injector for the host element of the component. </p>\n<ul>\n<li>\n<p>See an <a href=\"guide/dependency-injection-in-action#qualify-dependency-lookup\">example</a> of using <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a></code> together with <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code>, another parameter decorator that lets you handle the null case if no provider is found.</p>\n</li>\n<li>\n<p>Learn more about the <a href=\"https://blog.angularindepth.com/a-curios-case-of-the-host-decorator-and-element-injectors-in-angular-582562abcf0a\"><code>@Host</code> decorator and Element Injectors</a>.</p>\n</li>\n</ul>\n</div>\n<p>If you only register providers with the root injector at the top level (typically the root <code>AppModule</code>), the tree of injectors appears to be flat.\nAll requests bubble up to the root injector, whether you configured it with the <code>bootstrapModule</code> method, or registered all providers with <code>root</code> in their own services.</p>\n<a id=\"component-injectors\"></a>\n<h2 id=\"component-injectors\">Component injectors<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#component-injectors\"><i class=\"material-icons\">link</i></a></h2>\n<p>The ability to configure one or more providers at different levels opens up interesting and useful possibilities.\nThe guide sample offers some scenarios where you might want to do so.</p>\n<h3 id=\"scenario-service-isolation\">Scenario: service isolation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#scenario-service-isolation\"><i class=\"material-icons\">link</i></a></h3>\n<p>Architectural reasons may lead you to restrict access to a service to the application domain where it belongs.\nFor example, the guide sample includes a <code>VillainsListComponent</code> that displays a list of villains.\nIt gets those villains from a <code>VillainsService</code>.</p>\n<p>If you provide <code>VillainsService</code> in the root <code>AppModule</code> (where you registered the <code>HeroesService</code>),\nthat would make the <code>VillainsService</code> available everywhere in the application, including the <em>Hero</em> workflows. If you later modified the <code>VillainsService</code>, you could break something in a hero component somewhere. Providing the service in the root <code>AppModule</code> creates that risk.</p>\n<p>Instead, you can provide the <code>VillainsService</code> in the <code>providers</code> metadata of the <code>VillainsListComponent</code> like this:</p>\n<code-example path=\"hierarchical-dependency-injection/src/app/villains-list.component.ts\" linenums=\"false\" header=\"src/app/villains-list.component.ts (metadata)\" region=\"metadata\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-villains-list',\n  templateUrl: './villains-list.component.html',\n  providers: [ VillainsService ]\n})\n\n</code-example>\n<p>By providing <code>VillainsService</code> in the <code>VillainsListComponent</code> metadata and nowhere else,\nthe service becomes available only in the <code>VillainsListComponent</code> and its sub-component tree.\nIt's still a singleton, but it's a singleton that exist solely in the <em>villain</em> domain.</p>\n<p>Now you know that a hero component can't access it. You've reduced your exposure to error.</p>\n<h3 id=\"scenario-multiple-edit-sessions\">Scenario: multiple edit sessions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#scenario-multiple-edit-sessions\"><i class=\"material-icons\">link</i></a></h3>\n<p>Many applications allow users to work on several open tasks at the same time.\nFor example, in a tax preparation application, the preparer could be working on several tax returns,\nswitching from one to the other throughout the day.</p>\n<p>This guide demonstrates that scenario with an example in the Tour of Heroes theme.\nImagine an outer <code>HeroListComponent</code> that displays a list of super heroes.</p>\n<p>To open a hero's tax return, the preparer clicks on a hero name, which opens a component for editing that return.\nEach selected hero tax return opens in its own component and multiple returns can be open at the same time.</p>\n<p>Each tax return component has the following characteristics:</p>\n<ul>\n<li>Is its own tax return editing session.</li>\n<li>Can change a tax return without affecting a return in another component.</li>\n<li>Has the ability to save the changes to its tax return or cancel them.</li>\n</ul>\n<figure>\n  <img src=\"generated/images/guide/dependency-injection/hid-heroes-anim.gif\" alt=\"Heroes in action\" width=\"500\" height=\"384\">\n</figure>\n<p>Suppose that the <code>HeroTaxReturnComponent</code> has logic to manage and restore changes.\nThat would be a pretty easy task for a simple hero tax return.\nIn the real world, with a rich tax return data model, the change management would be tricky.\nYou could delegate that management to a helper service, as this example does.</p>\n<p>Here is the <code>HeroTaxReturnService</code>.\nIt caches a single <code>HeroTaxReturn</code>, tracks changes to that return, and can save or restore it.\nIt also delegates to the application-wide singleton <code>HeroService</code>, which it gets by injection.</p>\n<code-example path=\"hierarchical-dependency-injection/src/app/hero-tax-return.service.ts\" header=\"src/app/hero-tax-return.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> }    from '@angular/core';\nimport { HeroTaxReturn } from './hero';\nimport { HeroesService } from './heroes.service';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class HeroTaxReturnService {\n  private currentTaxReturn: HeroTaxReturn;\n  private originalTaxReturn: HeroTaxReturn;\n\n  constructor(private heroService: HeroesService) { }\n\n  set taxReturn (htr: HeroTaxReturn) {\n    this.originalTaxReturn = htr;\n    this.currentTaxReturn  = htr.clone();\n  }\n\n  get taxReturn (): HeroTaxReturn {\n    return this.currentTaxReturn;\n  }\n\n  restoreTaxReturn() {\n    this.taxReturn = this.originalTaxReturn;\n  }\n\n  saveTaxReturn() {\n    this.taxReturn = this.currentTaxReturn;\n    this.heroService.saveTaxReturn(this.currentTaxReturn).subscribe();\n  }\n}\n\n\n</code-example>\n<p>Here is the <code>HeroTaxReturnComponent</code> that makes use of it.</p>\n<code-example path=\"hierarchical-dependency-injection/src/app/hero-tax-return.component.ts\" header=\"src/app/hero-tax-return.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/Output\" class=\"code-anchor\">Output</a> } from '@angular/core';\nimport { HeroTaxReturn }        from './hero';\nimport { HeroTaxReturnService } from './hero-tax-return.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-tax-return',\n  templateUrl: './hero-tax-return.component.html',\n  <a href=\"api/core/Component#styleUrls\" class=\"code-anchor\">styleUrls</a>: [ './hero-tax-return.component.css' ],\n  providers: [ HeroTaxReturnService ]\n})\nexport class HeroTaxReturnComponent {\n  <a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a> = '';\n\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() close = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;void>();\n\n  get taxReturn(): HeroTaxReturn {\n    return this.heroTaxReturnService.taxReturn;\n  }\n\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()\n  set taxReturn (htr: HeroTaxReturn) {\n    this.heroTaxReturnService.taxReturn = htr;\n  }\n\n  constructor(private heroTaxReturnService: HeroTaxReturnService) { }\n\n  onCanceled()  {\n    this.flashMessage('Canceled');\n    this.heroTaxReturnService.restoreTaxReturn();\n  };\n\n  onClose()  { this.close.emit(); };\n\n  onSaved() {\n    this.flashMessage('Saved');\n    this.heroTaxReturnService.saveTaxReturn();\n  }\n\n  flashMessage(msg: string) {\n    this.message = msg;\n    setTimeout(() => this.message = '', 500);\n  }\n}\n\n\n</code-example>\n<p>The <em>tax-return-to-edit</em> arrives via the input property which is implemented with getters and setters.\nThe setter initializes the component's own instance of the <code>HeroTaxReturnService</code> with the incoming return.\nThe getter always returns what that service says is the current state of the hero.\nThe component also asks the service to save and restore this tax return.</p>\n<p>This won't work if the service is an application-wide singleton.\nEvery component would share the same service instance, and each component would overwrite the tax return that belonged to another hero.</p>\n<p>To prevent this, we configure the component-level injector of <code>HeroTaxReturnComponent</code> to provide the service, using the  <code>providers</code> property in the component metadata.</p>\n<code-example path=\"hierarchical-dependency-injection/src/app/hero-tax-return.component.ts\" linenums=\"false\" header=\"src/app/hero-tax-return.component.ts (providers)\" region=\"providers\">\nproviders: [ HeroTaxReturnService ]\n\n</code-example>\n<p>The <code>HeroTaxReturnComponent</code> has its own provider of the <code>HeroTaxReturnService</code>.\nRecall that every component <em>instance</em> has its own injector.\nProviding the service at the component level ensures that <em>every</em> instance of the component gets its own, private instance of the service, and no tax return gets overwritten.</p>\n<div class=\"alert is-helpful\">\n<p>The rest of the scenario code relies on other Angular features and techniques that you can learn about elsewhere in the documentation.\nYou can review it and download it from the <live-example></live-example>.</p>\n</div>\n<h3 id=\"scenario-specialized-providers\">Scenario: specialized providers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#scenario-specialized-providers\"><i class=\"material-icons\">link</i></a></h3>\n<p>Another reason to re-provide a service at another level is to substitute a <em>more specialized</em> implementation of that service, deeper in the component tree.</p>\n<p>Consider a Car component that depends on several services.\nSuppose you configured the root injector (marked as A) with <em>generic</em> providers for\n<code>CarService</code>, <code>EngineService</code> and <code>TiresService</code>.</p>\n<p>You create a car component (A) that displays a car constructed from these three generic services.</p>\n<p>Then you create a child component (B) that defines its own, <em>specialized</em> providers for <code>CarService</code> and <code>EngineService</code>\nthat have special capabilities suitable for whatever is going on in component (B).</p>\n<p>Component (B) is the parent of another component (C) that defines its own, even <em>more specialized</em> provider for <code>CarService</code>.</p>\n<figure>\n  <img src=\"generated/images/guide/dependency-injection/car-components.png\" alt=\"car components\" width=\"338\" height=\"201\">\n</figure>\n<p>Behind the scenes, each component sets up its own injector with zero, one, or more providers defined for that component itself.</p>\n<p>When you resolve an instance of <code>Car</code> at the deepest component (C),\nits injector produces an instance of <code>Car</code> resolved by injector (C) with an <code>Engine</code> resolved by injector (B) and\n<code>Tires</code> resolved by the root injector (A).</p>\n<figure>\n  <img src=\"generated/images/guide/dependency-injection/injector-tree.png\" alt=\"car injector tree\" width=\"600\" height=\"248\">\n</figure>\n<div class=\"alert is-helpful\">\n<p>The code for this <em>cars</em> scenario is in the <code>car.components.ts</code> and <code>car.services.ts</code> files of the sample\nwhich you can review and download from the <live-example></live-example>.</p>\n</div>\n\n</div>\n\n<!-- links to this doc:\n - guide/change-log\n - guide/dependency-injection\n - guide/glossary\n - guide/upgrade\n-->\n<!-- links from this doc:\n - api/common/HashLocationStrategy\n - api/common/LocationStrategy\n - api/common/http/HttpErrorResponse#message\n - api/core/Component\n - api/core/Component#styleUrls\n - api/core/Component#template\n - api/core/Directive\n - api/core/EventEmitter\n - api/core/Host\n - api/core/Injectable\n - api/core/Injectable#providedIn\n - api/core/Input\n - api/core/NgModule\n - api/core/Optional\n - api/core/Output\n - api/platform-browser/platformBrowser\n - cli\n - guide/dependency-injection-in-action#qualify-dependency-lookup\n - guide/dependency-injection-providers#tree-shakable-providers\n - guide/hierarchical-dependency-injection#component-injectors\n - guide/hierarchical-dependency-injection#component-level-injectors\n - guide/hierarchical-dependency-injection#element-injectors\n - guide/hierarchical-dependency-injection#hierarchical-dependency-injectors\n - guide/hierarchical-dependency-injection#injectable-level-configuration\n - guide/hierarchical-dependency-injection#injector-bubbling\n - guide/hierarchical-dependency-injection#ngmodule-level-injectors\n - guide/hierarchical-dependency-injection#scenario-multiple-edit-sessions\n - guide/hierarchical-dependency-injection#scenario-service-isolation\n - guide/hierarchical-dependency-injection#scenario-specialized-providers\n - guide/hierarchical-dependency-injection#where-to-configure-providers\n - guide/lazy-loading-ngmodules\n - guide/router#location-strategy\n - https://blog.angularindepth.com/a-curios-case-of-the-host-decorator-and-element-injectors-in-angular-582562abcf0a\n - https://blog.angularindepth.com/angular-dependency-injection-and-tree-shakeable-tokens-4588a8f70d5d\n - https://github.com/angular/angular/edit/master/aio/content/guide/hierarchical-dependency-injection.md?message=docs%3A%20describe%20your%20change...\n-->"
}