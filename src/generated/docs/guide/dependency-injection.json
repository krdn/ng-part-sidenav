{
  "id": "guide/dependency-injection",
  "title": "Dependency Injection in Angular",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/dependency-injection.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<h1 id=\"dependency-injection-in-angular\">Dependency Injection in Angular<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#dependency-injection-in-angular\"><i class=\"material-icons\">link</i></a></h1>\n<p>Dependency injection (DI), is an important application design pattern.\nAngular has its own DI framework, which is typically\nused in the design of Angular applications to increase their efficiency and modularity.</p>\n<p>Dependencies are services or objects that a class needs to perform its function.\nDI is a coding pattern in which a class asks for dependencies from external sources rather than creating them itself. </p>\n<p>In Angular, the DI framework provides declared dependencies to a class when that class is instantiated. This guide explains how DI works in Angular, and how you use it to make your apps flexible, efficient, and robust, as well as testable and maintainable.</p>\n<div class=\"alert is-helpful\">\n<p> You can run the <live-example></live-example> of the sample app that accompanies this guide.</p>\n</div>\n<p>Start by reviewing this simplified version of the <em>heroes</em> feature\nfrom the <a href=\"tutorial/\">The Tour of Heroes</a>. This simple version doesn't use DI; we'll walk through converting it to do so.</p>\n<code-tabs>\n  <code-pane header=\"src/app/heroes/heroes.component.ts\" path=\"dependency-injection/src/app/heroes/heroes.component.1.ts\" region=\"v1\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-heroes',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n    &#x3C;h2>Heroes&#x3C;/h2>\n    &#x3C;app-hero-list>&#x3C;/app-hero-list>\n  `\n})\nexport class HeroesComponent { }\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/heroes/hero-list.component.ts\" path=\"dependency-injection/src/app/heroes/hero-list.component.1.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> }   from '@angular/core';\nimport { HEROES }      from './mock-heroes';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-list',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n    &#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\">\n      {{hero.id}} - {{hero.name}}\n    &#x3C;/div>\n  `\n})\nexport class HeroListComponent {\n  heroes = HEROES;\n}\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/heroes/hero.ts\" path=\"dependency-injection/src/app/heroes/hero.ts\">\nexport class Hero {\n  id: number;\n  name: string;\n  isSecret = false;\n}\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/heroes/mock-heroes.ts\" path=\"dependency-injection/src/app/heroes/mock-heroes.ts\">\nimport { Hero } from './hero';\n\nexport const HEROES: Hero[] = [\n  { id: 11, isSecret: false, name: 'Mr. Nice' },\n  { id: 12, isSecret: false, name: 'Narco' },\n  { id: 13, isSecret: false, name: 'Bombasto' },\n  { id: 14, isSecret: false, name: 'Celeritas' },\n  { id: 15, isSecret: false, name: 'Magneta' },\n  { id: 16, isSecret: false, name: 'RubberMan' },\n  { id: 17, isSecret: false, name: 'Dynama' },\n  { id: 18, isSecret: true,  name: 'Dr IQ' },\n  { id: 19, isSecret: true,  name: 'Magma' },\n  { id: 20, isSecret: true,  name: 'Tornado' }\n];\n\n\n</code-pane>\n\n</code-tabs>\n<p><code>HeroesComponent</code> is the top-level heroes component.\nIts only purpose is to display <code>HeroListComponent</code>, which displays a list of hero names.</p>\n<p>This version of the <code>HeroListComponent</code> gets heroes from the <code>HEROES</code> array, an in-memory collection\ndefined in a separate <code>mock-heroes</code> file.</p>\n<code-example header=\"src/app/heroes/hero-list.component.ts (class)\" path=\"dependency-injection/src/app/heroes/hero-list.component.1.ts\" region=\"class\">\nexport class HeroListComponent {\n  heroes = HEROES;\n}\n\n</code-example>\n<p>This approach works for prototyping, but is not robust or maintainable.\nAs soon as you try to test this component or get heroes from a remote server,\nyou have to change the implementation of <code>HeroesListComponent</code> and\nreplace every use of the <code>HEROES</code> mock data.</p>\n<h2 id=\"create-and-register-an-injectable-service\">Create and register an injectable service<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#create-and-register-an-injectable-service\"><i class=\"material-icons\">link</i></a></h2>\n<p>The DI framework lets you supply data to a component from an injectable <em>service</em> class, defined in its own file. To demonstrate, we'll create an injectable service class that provides a list of heroes, and register that class as a provider of that service.</p>\n<div class=\"alert is-helpful\">\n<p>Having multiple classes in the same file can be confusing. We generally recommend that you define components and services in separate files.</p>\n<p>If you do combine a component and service in the same file,\nit is important to define the service first, and then the component. If you define the component before the service, you get a run-time null reference error. </p>\n<p>It is possible to define the component first with the help of the <code><a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>()</code> method as explained in this <a href=\"http://blog.thoughtram.io/angular/2015/09/03/forward-references-in-angular-2.html\">blog post</a>.</p>\n<p>You can also use forward references to break circular dependencies.\nSee an example in the <a href=\"guide/dependency-injection-in-action#forwardref\">DI Cookbook</a>.</p>\n</div>\n<h3 id=\"create-an-injectable-service-class\">Create an injectable service class<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#create-an-injectable-service-class\"><i class=\"material-icons\">link</i></a></h3>\n<p>The <a href=\"cli\">Angular CLI</a> can generate a new <code>HeroService</code> class in the <code>src/app/heroes</code> folder with this command.</p>\n<code-example language=\"sh\" class=\"code-shell\">\nng generate service heroes/hero\n</code-example>\n<p>The command creates the following <code>HeroService</code> skeleton.</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.0.ts\" header=\"src/app/heroes/hero.service.ts (CLI-generated)\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root',\n})\nexport class HeroService {\n  constructor() { }\n}\n\n\n</code-example>\n<p>The <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> is an essential ingredient in every Angular service definition. The rest of the class has been written to expose a <code>getHeroes</code> method that returns the same mock data as before. (A real app would probably get its data asynchronously from a remote server, but we'll ignore that to focus on the mechanics of injecting the service.)</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.3.ts\" header=\"src/app/heroes/hero.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { HEROES } from './mock-heroes';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  // we declare that this service should be created\n  // by the root application injector.\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root',\n})\nexport class HeroService {\n  getHeroes() { return HEROES; }\n}\n\n\n</code-example>\n<a id=\"injector-config\"></a>\n<a id=\"bootstrap\"></a>\n<h3 id=\"configure-an-injector-with-a-service-provider\">Configure an injector with a service provider<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#configure-an-injector-with-a-service-provider\"><i class=\"material-icons\">link</i></a></h3>\n<p>The class we have created provides a service. The <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> decorator marks it as a service\nthat can be injected, but Angular can't actually inject it anywhere until you configure\nan Angular <a href=\"guide/glossary#injector\">dependency injector</a> with a <a href=\"guide/glossary#provider\">provider</a> of that service. </p>\n<p>The injector is responsible for creating service instances and injecting them into classes like <code>HeroListComponent</code>.<br>\nYou rarely create an Angular injector yourself. Angular creates injectors for you as it executes the app, starting with the <em>root injector</em> that it creates during the <a href=\"guide/bootstrapping\">bootstrap process</a>.</p>\n<p>A provider tells an injector <em>how to create the service</em>.\nYou must configure an injector with a provider before that injector can create a service (or provide any other kind of dependency). </p>\n<p>A provider can be the service class itself, so that the injector can use <code>new</code> to create an instance.\nYou might also define more than one class to provide the same service in different ways,\nand configure different injectors with different providers.</p>\n<div class=\"alert is-helpful\">\n<p>Injectors are inherited, which means that if a given injector can't resolve a dependency,\nit asks the parent injector to resolve it.<br>\nA component can get services from its own injector,\nfrom the injectors of its component ancestors,\nfrom the injector of its parent NgModule, or from the <code>root</code> injector. </p>\n<ul>\n<li>\n<p>Learn more about the <a href=\"guide/dependency-injection-providers\">different kinds of providers</a>.</p>\n</li>\n<li>\n<p>Learn more about  how the <a href=\"guide/hierarchical-dependency-injection\">injector hierarchy</a> works.</p>\n</li>\n</ul>\n</div>\n<p>You can configure injectors with providers at different levels of your app, by setting a metadata value in one of three places:</p>\n<ul>\n<li>\n<p>In the <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> decorator for the service itself.</p>\n</li>\n<li>\n<p>In the <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> decorator for an NgModule.</p>\n</li>\n<li>\n<p>In the <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> decorator for a component. </p>\n</li>\n</ul>\n<p>The <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> decorator has the <code><a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a></code> metadata option, where you can specify the provider of the decorated service class with the <code>root</code> injector, or with the injector for a specific NgModule.</p>\n<p>The <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> and <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> decorators have the <code>providers</code> metadata option, where you can configure providers for NgModule-level or component-level injectors.</p>\n<div class=\"alert is-helpful\">\n<p>Components are directives, and the <code>providers</code> option is inherited from <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code>. You can also configure providers for directives and pipes at the same level as the component.</p>\n<p>Learn more about <a href=\"guide/hierarchical-dependency-injection#where-to-register\">where to configure providers</a>.</p>\n</div>\n<a id=\"injector-config\"></a>\n<p>\n<a id=\"bootstrap\"></a></p>\n<h2 id=\"injecting-services\">Injecting services<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#injecting-services\"><i class=\"material-icons\">link</i></a></h2>\n<p>In order for <code>HeroListComponent</code> to get heroes from <code>HeroService</code>, it needs to ask for <code>HeroService</code> to be injected, rather than creating it's own <code>HeroService</code> instance with <code>new</code>.</p>\n<p>You can tell Angular to inject a dependency in a component's constructor by specifying a <strong>constructor parameter with the dependency type</strong>. Here's the <code>HeroListComponent</code> constructor, asking for the <code>HeroService</code> to be injected.</p>\n<code-example header=\"src/app/heroes/hero-list.component (constructor signature)\" path=\"dependency-injection/src/app/heroes/hero-list.component.ts\" region=\"ctor-signature\">\nconstructor(heroService: HeroService)\n\n</code-example>\n<p>Of course, <code>HeroListComponent</code> should do something with the injected <code>HeroService</code>.\nHere's the revised component, making use of the injected service, side-by-side with the previous version for comparison.</p>\n<code-tabs>\n  <code-pane header=\"hero-list.component (with DI)\" path=\"dependency-injection/src/app/heroes/hero-list.component.2.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> }   from '@angular/core';\nimport { Hero }        from './hero';\nimport { HeroService } from './hero.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-list',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n    &#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\">\n      {{hero.id}} - {{hero.name}}\n    &#x3C;/div>\n  `\n})\nexport class HeroListComponent {\n  heroes: Hero[];\n\n  constructor(heroService: HeroService) {\n    this.heroes = heroService.getHeroes();\n  }\n}\n\n\n</code-pane>\n\n  <code-pane header=\"hero-list.component (without DI)\" path=\"dependency-injection/src/app/heroes/hero-list.component.1.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> }   from '@angular/core';\nimport { HEROES }      from './mock-heroes';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-list',\n  <a href=\"api/core/Component#template\" class=\"code-anchor\">template</a>: `\n    &#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\">\n      {{hero.id}} - {{hero.name}}\n    &#x3C;/div>\n  `\n})\nexport class HeroListComponent {\n  heroes = HEROES;\n}\n\n\n</code-pane>\n</code-tabs>\n<p><code>HeroService</code> must be provided in some parent injector. The code in <code>HeroListComponent</code> doesn't depend on where <code>HeroService</code> comes from.\nIf you decided to provide <code>HeroService</code> in <code>AppModule</code>, <code>HeroListComponent</code> wouldn't change.</p>\n<a id=\"singleton-services\"></a>\n<a id=\"component-child-injectors\"></a>\n<h3 id=\"injector-hierarchy-and-service-instances\">Injector hierarchy and service instances<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#injector-hierarchy-and-service-instances\"><i class=\"material-icons\">link</i></a></h3>\n<p>Services are singletons <em>within the scope of an injector</em>. That is, there is at most one instance of a service in a given injector. </p>\n<p>There is only one root injector for an app. Providing <code>UserService</code> at the <code>root</code> or <code>AppModule</code> level means it is registered with the root injector. There is just one <code>UserService</code> instance in the entire app and every class that injects <code>UserService</code> gets this service instance <em>unless</em> you configure another provider with a <em>child injector</em>.</p>\n<p>Angular DI has a <a href=\"guide/hierarchical-dependency-injection\">hierarchical injection system</a>, which means that nested injectors can create their own service instances.\nAngular regularly creates nested injectors. Whenever Angular creates a new instance of a component that has <code>providers</code> specified in <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code>, it also creates a new <em>child injector</em> for that instance.\nSimilarly, when a new NgModule is lazy-loaded at run time, Angular can create an injector for it with its own providers. </p>\n<p>Child modules and component injectors are independent of each other, and create their own separate instances of the provided services. When Angular destroys an NgModule or component instance, it also destroys that injector and that injector's service instances. </p>\n<p>Thanks to <a href=\"guide/hierarchical-dependency-injection\">injector inheritance</a>,\nyou can still inject application-wide services into these components.\nA component's injector is a child of its parent component's injector, and inherits from all ancestor injectors all the way back to the application's <em>root</em> injector. Angular can inject a service provided by any injector in that lineage.</p>\n<p>For example, Angular can inject <code>HeroListComponent</code> with both the <code>HeroService</code> provided in <code>HeroComponent</code> and the <code>UserService</code> provided in <code>AppModule</code>.</p>\n<a id=\"testing-the-component\"></a>\n<h2 id=\"testing-components-with-dependencies\">Testing components with dependencies<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#testing-components-with-dependencies\"><i class=\"material-icons\">link</i></a></h2>\n<p>Designing a class with dependency injection makes the class easier to test.\nListing dependencies as constructor parameters may be all you need to test application parts effectively.</p>\n<p>For example, you can create a new <code>HeroListComponent</code> with a mock service that you can manipulate\nunder test.</p>\n<code-example path=\"dependency-injection/src/app/test.component.ts\" region=\"spec\" header=\"src/app/test.component.ts\" linenums=\"false\">\nconst expectedHeroes = [{name: 'A'}, {name: 'B'}]\nconst mockService = &#x3C;HeroService> {getHeroes: () => expectedHeroes }\n\nit('should have heroes when HeroListComponent created', () => {\n  // Pass the mock to the constructor as the Angular injector would\n  const component = new HeroListComponent(mockService);\n  expect(component.heroes.length).toEqual(expectedHeroes.length);\n});\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p>Learn more in the <a href=\"guide/testing\">Testing</a> guide.</p>\n</div>\n<a id=\"service-needs-service\"></a>\n<h2 id=\"services-that-need-other-services\">Services that need other services<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#services-that-need-other-services\"><i class=\"material-icons\">link</i></a></h2>\n<p>Service can have their own dependencies. <code>HeroService</code> is very simple and doesn't have any dependencies of its own. Suppose, however, that you want it to report its activities through a logging service. You can apply the same <em>constructor injection</em> pattern,\nadding a constructor that takes a <code>Logger</code> parameter.</p>\n<p>Here is the revised <code>HeroService</code> that injects <code>Logger</code>, side by side with the previous service for comparison.</p>\n<code-tabs>\n\n  <code-pane header=\"src/app/heroes/hero.service (v2)\" path=\"dependency-injection/src/app/heroes/hero.service.2.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { HEROES }     from './mock-heroes';\nimport { Logger }     from '../logger.service';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root',\n})\nexport class HeroService {\n\n  constructor(private logger: Logger) {  }\n\n  getHeroes() {\n    this.logger.log('Getting heroes ...');\n    return HEROES;\n  }\n}\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/heroes/hero.service (v1)\" path=\"dependency-injection/src/app/heroes/hero.service.1.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { HEROES }     from './mock-heroes';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root',\n})\nexport class HeroService {\n  getHeroes() { return HEROES; }\n}\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/logger.service\" path=\"dependency-injection/src/app/logger.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  <a href=\"api/core/Injectable#providedIn\" class=\"code-anchor\">providedIn</a>: 'root'\n})\nexport class Logger {\n  logs: string[] = []; // capture logs for testing\n\n  <a href=\"api/animations/browser/testing/MockAnimationDriver#log\" class=\"code-anchor\">log</a>(<a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a>: string) {\n    this.logs.push(<a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a>);\n    console.log(<a href=\"api/common/http/HttpErrorResponse#message\" class=\"code-anchor\">message</a>);\n  }\n}\n\n\n</code-pane>\n\n</code-tabs>\n<p>The constructor asks for an injected instance of <code>Logger</code> and stores it in a private field called <code>logger</code>. The <code>getHeroes()</code> method logs a message when asked to fetch heroes.</p>\n<p>Notice that the <code>Logger</code> service also has the <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> decorator, even though it might not need its own dependencies. In fact, the <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> decorator is <strong>required  for all services</strong>.</p>\n<p>When Angular creates a class whose constructor has parameters, it looks for type and injection metadata about those parameters so that it can inject the correct service.\nIf Angular can't find that parameter information, it throws an error.\nAngular can only find the parameter information <em>if the class has a decorator of some kind</em>.\nThe <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> decorator is the standard decorator for service classes.</p>\n<div class=\"alert is-helpful\">\n<p> The decorator requirement is imposed by TypeScript. TypeScript normally discards parameter type information when it <a href=\"guide/glossary#transpile\">transpiles</a> the code to JavaScript. TypeScript preserves this information if the class has a decorator and the <code>emitDecoratorMetadata</code> compiler option is set <code>true</code> in TypeScript's <code>tsconfig.json</code> configuration file. The CLI configures <code>tsconfig.json</code> with <code>emitDecoratorMetadata: true</code>.</p>\n<p> This means you're responsible for putting <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> on your service classes.</p>\n</div>\n<a id=\"token\"></a>\n<a id=\"injection-token\"></a>\n<h3 id=\"dependency-injection-tokens\">Dependency injection tokens<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#dependency-injection-tokens\"><i class=\"material-icons\">link</i></a></h3>\n<p>When you configure an injector with a provider, you associate that provider with a <a href=\"guide/glossary#di-token\">DI token</a>.\nThe injector maintains an internal <em>token-provider</em> map that it references when\nasked for a dependency. The token is the key to the map.</p>\n<p>In simple examples, the dependency value is an <em>instance</em>, and\nthe class <em>type</em> serves as its own lookup key.\nHere you get a <code>HeroService</code> directly from the injector by supplying the <code>HeroService</code> type as the token:</p>\n<code-example path=\"dependency-injection/src/app/injector.component.ts\" region=\"get-hero-service\" header=\"src/app/injector.component.ts\" linenums=\"false\">\nheroService: HeroService;\n\n</code-example>\n<p>The behavior is similar when you write a constructor that requires an injected class-based dependency.\nWhen you define a constructor parameter with the <code>HeroService</code> class type,\nAngular knows to inject the service associated with that <code>HeroService</code> class token:</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero-list.component.ts\" region=\"ctor-signature\" header=\"src/app/heroes/hero-list.component.ts\">\nconstructor(heroService: HeroService)\n\n</code-example>\n<p>Many dependency values are provided by classes, but not all. The expanded <em>provide</em> object lets you associate different kinds of providers with a DI token. </p>\n<ul>\n<li>Learn more about <a href=\"guide/dependency-injection-providers\">different kinds of providers</a>.</li>\n</ul>\n<a id=\"optional\"></a>\n<h3 id=\"optional-dependencies\">Optional dependencies<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#optional-dependencies\"><i class=\"material-icons\">link</i></a></h3>\n<p><code>HeroService</code> <em>requires</em> a logger, but what if it could get by without\none?</p>\n<p>When a component or service declares a dependency, the class constructor takes that dependency as a parameter.\nYou can tell Angular that the dependency is optional by annotating the\nconstructor parameter with <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code>.</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"import-optional\">\nimport { <a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a> } from '@angular/core';\n\n</code-example>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"provider-10-ctor\" linenums=\"false\">\nconstructor(@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() private logger: Logger) {\n  if (this.logger) {\n    this.logger.log(some_message);\n  }\n}\n\n</code-example>\n<p>When using <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code>, your code must be prepared for a null value. If you\ndon't register a logger provider anywhere, the injector sets the\nvalue of <code>logger</code> to null.</p>\n<div class=\"alert is-helpful\">\n<p><code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>()</code> and <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> are <em>parameter decorators</em>.  They alter the way the DI framework provides a dependency, by annotating the dependency parameter on the constructor of the class that requires the dependency.</p>\n<p>Learn more about parameter decorators in <a href=\"guide/hierarchical-dependency-injection\">Hierarchical Dependency Injectors</a>.</p>\n</div>\n<h2 id=\"summary\">Summary<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#summary\"><i class=\"material-icons\">link</i></a></h2>\n<p>You learned the basics of Angular dependency injection in this page.\nYou can register various kinds of providers,\nand you know how to ask for an injected object (such as a service) by\nadding a parameter to a constructor.</p>\n<p>Dive deeper into the capabilities and advanced feature of the Angular DI system in the following pages:</p>\n<ul>\n<li>\n<p>Learn more about nested injectors in\n<a href=\"guide/hierarchical-dependency-injection\">Hierarchical Dependency Injection</a>.</p>\n</li>\n<li>\n<p>Learn more about <a href=\"guide/dependency-injection-providers\">DI tokens and providers</a>.</p>\n</li>\n<li>\n<p><a href=\"guide/dependency-injection-in-action\">Dependency Injection in Action</a> is a cookbook for some of the interesting things you can do with DI.</p>\n</li>\n</ul>\n\n</div>\n\n<!-- links to this doc:\n - api/core/ClassProvider\n - api/core/ConstructorSansProvider\n - api/core/ExistingProvider\n - api/core/FactoryProvider\n - api/core/Inject\n - api/core/Injectable\n - api/core/Injector\n - api/core/Optional\n - api/core/Provider\n - api/core/StaticProvider\n - api/core/TypeProvider\n - api/core/ValueProvider\n - guide/architecture-services\n - guide/attribute-directives\n - guide/dependency-injection-providers\n - guide/glossary\n - guide/http\n - guide/ngmodule-api\n - guide/router\n - guide/sharing-ngmodules\n - guide/testing\n - guide/upgrade\n - tutorial/toh-pt4\n-->\n<!-- links from this doc:\n - api/animations/browser/testing/MockAnimationDriver#log\n - api/common/NgForOf\n - api/common/http/HttpErrorResponse#message\n - api/core/Component\n - api/core/Component#template\n - api/core/Directive\n - api/core/Inject\n - api/core/Injectable\n - api/core/Injectable#providedIn\n - api/core/NgModule\n - api/core/Optional\n - api/core/forwardRef\n - cli\n - guide/bootstrapping\n - guide/dependency-injection#configure-an-injector-with-a-service-provider\n - guide/dependency-injection#create-an-injectable-service-class\n - guide/dependency-injection#create-and-register-an-injectable-service\n - guide/dependency-injection#dependency-injection-in-angular\n - guide/dependency-injection#dependency-injection-tokens\n - guide/dependency-injection#injecting-services\n - guide/dependency-injection#injector-hierarchy-and-service-instances\n - guide/dependency-injection#optional-dependencies\n - guide/dependency-injection#services-that-need-other-services\n - guide/dependency-injection#summary\n - guide/dependency-injection#testing-components-with-dependencies\n - guide/dependency-injection-in-action\n - guide/dependency-injection-in-action#forwardref\n - guide/dependency-injection-providers\n - guide/glossary#di-token\n - guide/glossary#injector\n - guide/glossary#provider\n - guide/glossary#transpile\n - guide/hierarchical-dependency-injection\n - guide/hierarchical-dependency-injection#where-to-register\n - guide/testing\n - tutorial/\n - http://blog.thoughtram.io/angular/2015/09/03/forward-references-in-angular-2.html\n - https://github.com/angular/angular/edit/master/aio/content/guide/dependency-injection.md?message=docs%3A%20describe%20your%20change...\n-->"
}